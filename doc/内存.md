

### 内存五大分区

按照内存地址`从高(0xffffffff)到低(0x00000000)`的顺序排列，可分为5大分区：`栈区 -> 堆区 -> 全局静态区 -> 常量区 -> 代码区`。大致分布如下图所示👇

![img](https:////upload-images.jianshu.io/upload_images/3444487-fccce4214dda15ec.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/895/format/webp)

1. 栈区
   - 栈区的内存空间由`系统管理` --> 即方法调用开始时开辟空间，方法调用结束时回收该函数中所有的栈空间。
   - 栈区是从`高地址`向`低地址`扩展，是一块`连续的内存区域`，遵循`先进后出，后进先出(FILO)原则`，使用效率高。
   - 栈区的内存空间是在`运行时`由系统进行分配，
   - **缺点**：栈的空间大小有限定，vc的缺省是2M。栈不够用的情况一般是程序中分配了大量数组和递归函数层次太深。只要栈的剩余空间小于所申请空间，将报异常提示栈溢出。
   - 哪些变量是栈区的？例如`方法的入参，内部定义的局部变量`等，都存放在`栈区`。
2. 堆区
   - 最大的特点 --> 空间大，需程序员自己手动管理。(当然，在ARC时代也是系统自动管理的)
   - 堆区是从`低地址`向`高地址`扩展，与`栈区`相反，遵循`先进先出(FIFO)`的原则。
   - 堆区由系统api开辟空间(c/c++ --> `malloc、calloc、realloc`, oc --> `alloc` `new`)，这个空间可以是`不连续的`，以`链表`结构存在，
   - 开辟出的空间的`首地址`是在`栈区`，例如`LGPerson *person = [[LGPerson alloc] init];`这个person指向所指向的地址是在`栈区`。
   - 内存回收 --> `free回收`，做了`两件事`，一是释放堆区的内存，二是将栈区的指针置为nil。
   - **缺点**：有可能会产生内存泄漏。并且频繁地malloc和free会产生内存碎片（有点类似磁盘碎片），因为c分配动态内存时是寻找匹配的内存的。。
3. 全局静态区
   - 存放`全局变量` 和 `静态变量`。
   - 内存空间也是由`系统管理` -->`程序启动`时`开辟`，`程序结束`时`回收`，程序`执行期间一直存在`。
   - `static`修饰的变量`仅执行一次`，生命周期为`整个程序运行期`。
4. 常量区
   - 存放常量👇(整型、字符型，浮点型，字符串等)，整个程序运行期不能被改变。
     - `已初始化`的`全局变量`
     - `已初始化`的`静态变量`
   - 空间由`系统管理`，生命周期为`整个程序运行期`。
5. 代码区
   - 存放程序执行的`CPU指令`，一种二进制文件。（编译期将代码转换为CPU指令）

#### 示例

​	void f() { int* p=new int[5]; } 
​    这条短短的一句话就包含了堆与栈，通过new，分配了一块堆内存，那么指针p，分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针p。在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中，他在VC6下的汇编代码如下： 
​    00401028   push        14h 
​    0040102A   call        operator new (00401060) 
​    0040102F   add         esp,4 
​    00401032   mov         dword ptr [ebp-8],eax 
​    00401035   mov         eax,dword ptr [ebp-8] 
​    00401038   mov         dword ptr [ebp-4],eax 

#### 堆和栈的区别

  1、管理方式不同：栈是由编译器自动管理；堆的释放工作由程序员控制，容易产生memory leak。

  2、空间大小不同：32位系统下，堆内存可以达到4G的空间。而栈默认1M或2M。

  3、能否产生碎片不同； 堆中频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。而用栈则不会产生碎片，因为栈是先进后出的队列。

  4、生长方向不同：堆是向着内存地址增加的方向（向上）；栈来是向着内存地址减小的方向增长

  5、分配方式不同：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放。

  6、分配效率不同：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。	
		堆中，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。

#### 补充概念

> 1. [内存泄漏（memory leak）](https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.so.com%2Fdoc%2F6084712-6297814.html)：是指申请的内存空间使用完毕之后**未回收**。
>     一次内存泄露危害可以忽略，但若一直泄漏，无论有多少内存，迟早都会被占用光，最终导致程序`crash`。（因此，开发中我们要尽量避免内存泄漏的出现）
> 2. [内存溢出（out of memory）](https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.so.com%2Fdoc%2F6467899-6681594.html)：是指程序在申请内存时，没有足够的内存空间供其使用。
>     通俗理解就是内存不够用了，通常在运行大型应用或游戏时，应用或游戏所需要的内存远远超出了你主机内安装的内存所承受大小，就叫内存溢出。最终导致机器`重启`或者程序`crash`。

简单来说：

| 概念     | 区别说明                                                  |
| -------- | --------------------------------------------------------- |
| 内存泄漏 | 供应方（操作系统）能提供给需求方（App）的内存越来越少。   |
| 内存溢出 | 需求方（App）需要的内存过大，超过供应方（操作系统）负载。 |